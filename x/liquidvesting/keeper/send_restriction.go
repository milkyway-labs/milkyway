package keeper

import (
	"context"

	"cosmossdk.io/math"
	sdk "github.com/cosmos/cosmos-sdk/types"

	"github.com/milkyway-labs/milkyway/x/liquidvesting/types"
)

// SendRestrictionFn function that can be used in the x/bank module to block the
// transfer of the vested representation tokens.
func (k *Keeper) SendRestrictionFn(
	goCtx context.Context,
	from sdk.AccAddress,
	to sdk.AccAddress,
	amount sdk.Coins,
) (sdk.AccAddress, error) {
	fromAddrStr, err := k.accountKeeper.AddressCodec().BytesToString(from)
	if err != nil {
		return nil, err
	}
	toAddrStr, err := k.accountKeeper.AddressCodec().BytesToString(to)
	if err != nil {
		return nil, err
	}

	// Don't check when transferring from or to the module account, this is to allow
	// the minting and burning of the vested representations
	if toAddrStr == k.ModuleAddress || fromAddrStr == k.ModuleAddress {
		return to, nil
	}

	ctx := sdk.UnwrapSDKContext(goCtx)

	isToRestakingModule, err := k.isRestakingModule(ctx, to)
	if err != nil {
		return nil, err
	}
	isFromRestakingModule, err := k.isRestakingModule(ctx, from)
	if err != nil {
		return nil, err
	}

	// Get the user insurance fund
	var userInsuranceFund types.UserInsuranceFund
	updateInsuranceFund := false
	if isToRestakingModule {
		userInsuranceFund, err = k.GetUserInsuranceFund(ctx, from)
		if err != nil {
			return nil, err
		}
	} else if isFromRestakingModule {
		userInsuranceFund, err = k.GetUserInsuranceFund(ctx, to)
		if err != nil {
			return nil, err
		}
	}

	for _, coin := range amount {
		// Check if coin is a representation of a vested originalDenom
		if types.IsVestedRepresentationDenom(coin.Denom) {
			// Compute the coin to be available in the insurance fund
			required, err := k.getRequiredAmountInInsuranceFund(ctx, coin)
			if err != nil {
				return nil, err
			}
			// Here we need to check if the coin are being sent from the user
			// to a restaking module account or the other way around
			// since we need to restrict to send only to the restaking module
			switch {
			case isToRestakingModule:
				if !userInsuranceFund.Unused().AmountOf(required.Denom).GTE(required.Amount) {
					return nil, types.ErrInsufficientInsuranceFundBalance
				} else {
					userInsuranceFund.AddUsed(required)
					updateInsuranceFund = true
				}
			case isFromRestakingModule:
				// From module to account, the user has undelegated their tokens.
				userInsuranceFund.DecreaseUsed(required)
				updateInsuranceFund = true
			default:
				// Neither the sender nor the receiver is a restaking module
				// this means that the user is trying to send those tokens
				// somewhere else. Block it since the vested representation
				// can only be sent to the restaking module.
				return nil, types.ErrVestedRepresentationCannoteBeTransferred.Wrapf("coin %s", coin.Denom)
			}
		}
	}

	if updateInsuranceFund {
		if isToRestakingModule {
			err = k.insuranceFunds.Set(ctx, from, userInsuranceFund)
			if err != nil {
				return nil, err
			}
		} else if isFromRestakingModule {
			err = k.insuranceFunds.Set(ctx, to, userInsuranceFund)
			if err != nil {
				return nil, err
			}
		}
	}

	return to, nil
}

// isRestakingModule checks if the provided address is an address
// generated by the restaking module.
func (k *Keeper) isRestakingModule(ctx sdk.Context, account sdk.AccAddress) (bool, error) {
	accountString, err := k.accountKeeper.AddressCodec().BytesToString(account)
	if err != nil {
		return false, err
	}

	isModule, err := k.poolsKeeper.IsPoolAddress(ctx, accountString)
	if err != nil || isModule {
		return isModule, err
	}

	isModule, err = k.servicesKeeper.IsServiceAddress(ctx, accountString)
	if err != nil || isModule {
		return isModule, err
	}

	return k.operatorsKeeper.IsOperatorAddress(ctx, accountString)
}

// getRequiredAmountInInsuranceFund returns the required coin that should
// be available in the user's insurance fund in order to cover the provide amount.
func (k *Keeper) getRequiredAmountInInsuranceFund(ctx sdk.Context, amount sdk.Coin) (sdk.Coin, error) {
	nativeDenom, err := types.VestedDenomToNative(amount.Denom)
	if err != nil {
		return sdk.Coin{}, err
	}

	params, err := k.GetParams(ctx)
	if err != nil {
		return sdk.Coin{}, err
	}

	requiredAmount := math.LegacyNewDecFromInt(amount.Amount).
		Mul(params.InsurancePercentage).QuoInt64(100).Ceil().TruncateInt()

	return sdk.NewCoin(nativeDenom, requiredAmount), nil
}
