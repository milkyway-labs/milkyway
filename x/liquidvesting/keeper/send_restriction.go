package keeper

import (
	"context"

	"cosmossdk.io/math"
	sdk "github.com/cosmos/cosmos-sdk/types"

	"github.com/milkyway-labs/milkyway/x/liquidvesting/types"
	restakingtypes "github.com/milkyway-labs/milkyway/x/restaking/types"
)

// BlockBeforeSend implements keeper.BankHooks.
func (k *Keeper) SendRestrictionFn(
	goCtx context.Context,
	from sdk.AccAddress,
	to sdk.AccAddress,
	amount sdk.Coins,
) (sdk.AccAddress, error) {
	// Don't check when transferring from or to the module account, this is to allow
	// the minting and burning of the vested representations
	if to.String() == k.moduleAddress || from.String() == k.moduleAddress {
		return to, nil
	}

	ctx := sdk.UnwrapSDKContext(goCtx)
	for _, coin := range amount {
		// Check if coin is a representation of a vested originalDenom
		if types.IsVestedRepresentationDenom(coin.Denom) {
			// Here we need to check if the coin are being sent from the user
			// to a restaking module account or the other way around
			// since we need to restrict to send only to the restaking module
			if k.isRestakingModule(ctx, to) {
				err := k.isCoveredByInsuranceFund(ctx, from, coin)
				if err != nil {
					return sdk.AccAddress{}, err
				}
			} else if !k.isRestakingModule(ctx, from) {
				// Neither the sender nor the receiver is a restaking module
				// this means that the user is trying to send those tokens
				// somewhere else. Block it since the vested representation
				// can only be sent to the restaking module.
				return sdk.AccAddress{}, types.ErrVestedRepresentationCannoteBeTransferred.Wrapf("coin %s", coin.Denom)
			}
		}
	}

	return to, nil
}

// isRestakingModule checks if the provided address is an address
// generated by the restaking module.
func (k *Keeper) isRestakingModule(ctx sdk.Context, account sdk.AccAddress) bool {
	accountString := account.String()
	return k.poolsKeeper.IsPoolDelegationsAddress(ctx, accountString) ||
		k.servicesKeeper.IsServiceDelegationsAddress(ctx, accountString) ||
		k.operatorsKeeper.IsOperatorDelegationsAddress(ctx, accountString)
}

// isCoveredByInsuranceFund checks if the provided amount once restaked is
// covered by the user's insurance fund.
func (k *Keeper) isCoveredByInsuranceFund(
	ctx sdk.Context,
	user sdk.AccAddress,
	restakedCoin sdk.Coin,
) error {
	totalDelegated, err := k.getUserDelegateAmount(ctx, user, restakedCoin.Denom)
	if err != nil {
		return err
	}

	// Get the params that we later use to compute the amount of
	// tokens that are covered by the user's insurance fund
	params, err := k.GetParams(ctx)
	if err != nil {
		return err
	}

	insuranceFund, err := k.GetUserInsuranceFundBalance(ctx, user)
	if err != nil {
		return err
	}
	// Get the native denom from the vested representation
	originalDenom, err := types.VestedDenomToNative(restakedCoin.Denom)
	if err != nil {
		return err
	}

	// Get the amount of native tokens stored inside the user's insurance fund
	found, insuranceFundCoin := insuranceFund.Find(originalDenom)
	if !found {
		return types.ErrInsufficientInsuranceFundBalance
	}

	newDelegatedAmount := totalDelegated.Add(math.LegacyNewDecFromInt(restakedCoin.Amount))
	// Compute the amount that should be present inside the insurance fund
	// to cover the new delegated amount
	requiredInsuranceFund := newDelegatedAmount.
		Mul(params.InsurancePercentage).QuoInt64(100).Ceil().TruncateInt()

	// Ensure that we have enough balance in the user's insurance fund to cover
	// the new delegated amount
	if insuranceFundCoin.Amount.LT(requiredInsuranceFund) {
		return types.ErrInsufficientInsuranceFundBalance.
			Wrapf("required: %s, current: %s", requiredInsuranceFund.String(), insuranceFundCoin.String())
	}

	return nil
}

func (k *Keeper) getUserDelegateAmount(ctx sdk.Context, user sdk.AccAddress, denom string) (math.LegacyDec, error) {
	totalAmount := math.LegacyNewDec(0)

	// Get the amount from the pool delegation
	pool, found := k.poolsKeeper.GetPoolByDenom(ctx, denom)
	if found {
		delegation, found := k.restakingKeeper.GetPoolDelegation(ctx, pool.GetID(), user.String())
		if found {
			delegatedToPool := pool.TokensFromShares(delegation.Shares)
			// Pool contains only a single asset
			if len(delegatedToPool) > 0 {
				totalAmount = totalAmount.Add(delegatedToPool[0].Amount)
			}
		}
	}

	// Process the user's service delegations
	err := k.restakingKeeper.IterateUserServiceDelegations(ctx, user.String(),
		func(delegation restakingtypes.Delegation) (bool, error) {
			service, found := k.servicesKeeper.GetService(ctx, delegation.TargetID)
			if found {
				totalAmount = totalAmount.Add(
					service.TokensFromShares(delegation.Shares).AmountOf(denom))
			}
			return false, nil
		})
	if err != nil {
		return math.LegacyDec{}, err
	}

	// Process the user's operators delegations
	err = k.restakingKeeper.IterateUserOperatorDelegations(ctx, user.String(),
		func(delegation restakingtypes.Delegation) (bool, error) {
			operator, found := k.operatorsKeeper.GetOperator(ctx, delegation.TargetID)
			if found {
				totalAmount = totalAmount.Add(
					operator.TokensFromShares(delegation.Shares).AmountOf(denom))
			}
			return false, nil
		})
	if err != nil {
		return math.LegacyDec{}, err
	}

	return totalAmount, nil
}
