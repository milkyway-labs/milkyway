package keeper

import (
	"context"

	"cosmossdk.io/errors"
	sdk "github.com/cosmos/cosmos-sdk/types"

	"github.com/milkyway-labs/milkyway/v5/x/liquidvesting/types"
)

// SendRestrictionFn function that can be used in the x/bank module to block the
// transfer of the locked representation tokens.
func (k *Keeper) SendRestrictionFn(ctx context.Context, from sdk.AccAddress, to sdk.AccAddress, amount sdk.Coins) (sdk.AccAddress, error) {
	fromAddrStr, err := k.accountKeeper.AddressCodec().BytesToString(from)
	if err != nil {
		return nil, err
	}
	toAddrStr, err := k.accountKeeper.AddressCodec().BytesToString(to)
	if err != nil {
		return nil, err
	}

	// Don't check when transferring from or to the module account, this is to allow
	// the minting and burning of the locked representations
	if toAddrStr == k.ModuleAddress || fromAddrStr == k.ModuleAddress {
		return to, nil
	}

	isToRestakingTarget, err := k.isRestakingTarget(ctx, to)
	if err != nil {
		return nil, err
	}
	isFromRestakingTarget, err := k.isRestakingTarget(ctx, from)
	if err != nil {
		return nil, err
	}

	if isFromRestakingTarget && isToRestakingTarget {
		return nil, types.ErrTransferBetweenTargetsNotAllowed
	}

	for _, coin := range amount {
		// Check if coin is a representation of a locked originalDenom
		if !types.IsLockedRepresentationDenom(coin.Denom) {
			continue
		}

		// Here we need to check if the coin are being sent from the user
		// to a restaking module account or the other way around
		// since we need to restrict to send only to the restaking module
		if !isToRestakingTarget && !isFromRestakingTarget {
			// Neither the sender nor the receiver is a restaking module
			// this means that the user is trying to send those tokens
			// somewhere else. Block it since the locked representation
			// can only be sent to the restaking module.
			return nil, errors.Wrapf(types.ErrLockedRepresentationCannotBeTransferred, "coin %s", coin.Denom)
		}
	}

	return to, nil
}

// isRestakingTarget checks if the provided address is an address
// generated by the restaking module.
func (k *Keeper) isRestakingTarget(ctx context.Context, account sdk.AccAddress) (bool, error) {
	accountString, err := k.accountKeeper.AddressCodec().BytesToString(account)
	if err != nil {
		return false, err
	}

	isModule, err := k.poolsKeeper.IsPoolAddress(ctx, accountString)
	if err != nil || isModule {
		return isModule, err
	}

	isModule, err = k.servicesKeeper.IsServiceAddress(ctx, accountString)
	if err != nil || isModule {
		return isModule, err
	}

	return k.operatorsKeeper.IsOperatorAddress(ctx, accountString)
}
