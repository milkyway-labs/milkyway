package keeper

import (
	"context"

	"cosmossdk.io/math"
	sdk "github.com/cosmos/cosmos-sdk/types"

	bankkeeper "github.com/milkyway-labs/milkyway/x/bank/keeper"
	"github.com/milkyway-labs/milkyway/x/liquidvesting/types"
	restakingtypes "github.com/milkyway-labs/milkyway/x/restaking/types"
)

var _ bankkeeper.BankHooks = BankHooks{}

type BankHooks struct {
	*Keeper
}

func (k *Keeper) BankHooks() BankHooks {
	return BankHooks{k}
}

// BlockBeforeSend implements keeper.BankHooks.
func (h BankHooks) BlockBeforeSend(
	goCtx context.Context,
	from sdk.AccAddress,
	to sdk.AccAddress,
	amount sdk.Coins,
) error {
	// Don't check when transferring from or to the module account, this is to allow
	// the minting and burning of the vested representations
	if to.String() == h.moduleAddress || from.String() == h.moduleAddress {
		return nil
	}

	ctx := sdk.UnwrapSDKContext(goCtx)
	for _, coin := range amount {
		// Check if coin is a representation of a vested originalDenom
		if types.IsVestedRepresentationDenom(coin.Denom) {
			// Here we need to check if the coin are being sent from the user
			// to a restaking module account or the other way around
			// since we need to restrict to send only to the restaking module
			if h.isRestakingModule(ctx, to) {
				err := h.isCoveredByInsuranceFund(ctx, from, coin)
				if err != nil {
					return err
				}
			} else if !h.isRestakingModule(ctx, from) {
				// Neither the sender nor the receiver is a restaking module
				// this means that the user is trying to send those tokens
				// somewhere else. Block it since the vested representation
				// can only be sent to the restaking module.
				return types.ErrVestedRepresentationCannoteBeTransferred.Wrapf("coin %s", coin.Denom)
			}
		}
	}

	return nil
}

// isRestakingModule checks if the provided address is an address
// generated by the restaking module.
func (h BankHooks) isRestakingModule(ctx sdk.Context, account sdk.AccAddress) bool {
	accountString := account.String()
	return h.PoolsKeeper.IsPoolDelegationsAddress(ctx, accountString) ||
		h.ServicesKeeper.IsServiceDelegationsAddress(ctx, accountString) ||
		h.OperatorsKeeper.IsOperatorDelegationsAddress(ctx, accountString)
}

// isCoveredByInsuranceFund checks if the provided amount once restaked is
// covered by the user's insurance fund.
func (h BankHooks) isCoveredByInsuranceFund(
	ctx sdk.Context,
	user sdk.AccAddress,
	restakedCoin sdk.Coin,
) error {
	totalDelegated, err := h.getUserDelegateAmount(ctx, user, restakedCoin.Denom)
	if err != nil {
		return err
	}

	// Get the params that we later user to compute the amount of
	// tokens that are covered by the user's insurance fund
	params, err := h.GetParams(ctx)
	if err != nil {
		return err
	}

	insuranceFund, err := h.GetUserInsuranceFundBalance(ctx, user)
	if err != nil {
		return err
	}
	// Get the native denom from the vested representation
	originalDenom, err := types.VestedDenomToNative(restakedCoin.Denom)
	if err != nil {
		return err
	}

	// Get the amount of native tokens stored inside the user's insurance fund
	found, insuranceFundCoin := insuranceFund.Find(originalDenom)
	if !found {
		return types.ErrInsufficientInsuranceFundBalance
	}

	newDelegatedAmount := totalDelegated.Add(math.LegacyNewDecFromInt(restakedCoin.Amount))
	// Compute the amount that should be present inside the insurance fund
	// to cover the new delegated amount
	requiredInsuranceFund := newDelegatedAmount.
		Mul(params.InsurancePercentage).QuoInt64(100).Ceil().TruncateInt()

	// Ensure that we have enough balance in the user's insurance fund to cover
	// the new delegated amount
	if insuranceFundCoin.Amount.LT(requiredInsuranceFund) {
		return types.ErrInsufficientInsuranceFundBalance.
			Wrapf("required: %s, current: %s", requiredInsuranceFund.String(), insuranceFundCoin.String())
	}

	return nil
}

func (h BankHooks) getUserDelegateAmount(ctx sdk.Context, user sdk.AccAddress, denom string) (math.LegacyDec, error) {
	totalAmount := math.LegacyNewDec(0)

	// Get the amount from the pool delegation
	pool, found := h.PoolsKeeper.GetPoolByDenom(ctx, denom)
	if found {
		delegation, found := h.RestakingKeeper.GetPoolDelegation(ctx, pool.GetID(), user.String())
		if found {
			delegatedToPool := pool.TokensFromShares(delegation.Shares)
			// Pool contains only a single asset
			if len(delegatedToPool) > 0 {
				totalAmount = totalAmount.Add(delegatedToPool[0].Amount)
			}
		}
	}

	// Process the user's service delegations
	err := h.RestakingKeeper.IterateUserServiceDelegations(ctx, user.String(),
		func(delegation restakingtypes.Delegation) (bool, error) {
			service, found := h.ServicesKeeper.GetService(ctx, delegation.TargetID)
			if found {
				for _, coin := range service.TokensFromShares(delegation.Shares) {
					if coin.Denom == denom {
						totalAmount = totalAmount.Add(coin.Amount)
					}
				}
			}
			return false, nil
		})
	if err != nil {
		return math.LegacyDec{}, err
	}

	// Process the user's operators delegations
	err = h.RestakingKeeper.IterateUserOperatorDelegations(ctx, user.String(),
		func(delegation restakingtypes.Delegation) (bool, error) {
			operator, found := h.OperatorsKeeper.GetOperator(ctx, delegation.TargetID)
			if found {
				for _, coin := range operator.TokensFromShares(delegation.Shares) {
					if coin.Denom == denom {
						totalAmount = totalAmount.Add(coin.Amount)
					}
				}
			}
			return false, nil
		})
	if err != nil {
		return math.LegacyDec{}, err
	}

	return totalAmount, nil
}

// TrackBeforeSend implements keeper.BankHooks.
func (h BankHooks) TrackBeforeSend(
	_ context.Context,
	_ sdk.AccAddress,
	_ sdk.AccAddress,
	_ sdk.Coins,
) {
	// Noting to do here.
}
